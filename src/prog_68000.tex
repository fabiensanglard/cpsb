\chapter{Control System}
The control system is the simplest ROM to build since it involves only compiling code and the hardest to get right because of the complexity of its dependencies and the components it needs to communicate with. 

\begin{figure}[H]
\sdraw{1.0}{control_arch}
\caption*{The control system components}
\end{figure}

While the latch toward the Sound system is a small API surface, the GFX API is huge. The interface to the Graphic System is bigger both in breadth (it features 64 registers) and depth (the expected GFXRAM data layout is non-trivial).

To our advantage, the Motorola 68000 is a target supported by the \textbf{G}NU \textbf{C}ompiler \textbf{C}ollection (GCC). This suite features a much more powerful linker script system than \icode{sdcc} which helps considerably to solve the memory mapping requirements.

All stages of the build graph rely on tools provided by GNU GCC. Compiling \icode{.c} code to \icode{.obj} is done via \icode{gcc} compiler. Assembling \icode{.s} files to \icode{.obj} files is taken care of by \icode{as} assembler . Finally, the \icode{ld} linker combines all \icode{.obj} together into raw instructions. 


\nbdraw{build_graph_ctrl}



At the end of the process, the logical m68k ROM is split into interleaved chip-sized ROMs according to the specifics of the target board (described in the hardware chapter).

Like the z80, bootstrapping is solved with a small assembler program named \icode{crt0.s}.

\section{Bootstrapping the 68000}
Contrary to a z80, a m68k does not have a set booting address. Instead, it reads an array of 64 32-bit integers called the "vector table". Located at \icode{0x000000}, this is where the CPU finds the values to initialize its registers such as the stack pointer (offset \icode{0}) and instruction pointer (offset \icode{1}).

\lstinputlisting[style=m68kStyle]{src/code/68000/crt0.s}

All other slots except for one (offset \icode{26}) point to a no-op routine.




\section{Auto-Interrupt}
\index{Interrupts!Programming 68000}
The 68000 has multiple interrupt modes. In its most complex form, \icode{IPL0}, \icode{IPL1}, and \icode{IPL2} encode a level of interrupt and the interrupt ID is retrieved via an external interrupt controller. This would be over-kill for the task at hand.

A simpler mode, auto-vector, makes the CPU jump directly based on the three IPL lines' state. Three lines are treated as bits giving a value within [0,7], which is used to look up the "vector table" starting at offset \icode{24}.

The 3-bit scheme uses \icode{IPL0} for bit 0, \icode{IPL1} for bit 1, and \icode{IPL2} for bit 2. With CPS-A INT only connected to \icode{IPL1}, handler \#2 is always called upon interrupt. Therefore, VSync must be placed at offset \icode{24 + 2 = 26}.

\lstinputlisting[style=m68kStyle]{src/code/68000/crt1.s}

The last piece of the \icode{\_boot} function sets up auto-vector mode and jump to \icode{main}.

\lstinputlisting[style=m68kStyle]{src/code/68000/crt2.s}






\section{Memory Map}
Like for the Sound System and its z80 memory space, we need to make sure the software behaves according to the memory map defined by the board PALs.

The compiler in the GNU Compiler Collection, \icode{gcc} does not have a placement keyword \icode{\_\_at} but even if it had been available, it would not have been enough to map large portions such as the 192 KiB of GFXRAM.

We can compensate for the lack of \icode{\_\_at} thanks to the power of \icode{ld}'s linker script system. The idea is to use a two step method:
\begin{enumerate}
\item Define memory regions in the script thanks to the \icode{MEMORY} keyword. Create segments where code/data are stored in regions based on read/write access types.
\item Connect regions and segments in the C code.
\end{enumerate}


\pagebreak

\subsection{Goal}
To avoid flipping pages, here is the memory map studied on page \pageref{m68k_mm}.

\begin{tabularx}{\textwidth}{rrrX}
\toprule    
  \textbf{Start } & \textbf{End  } & \textbf{Size } & \textbf{Function } \\               
  \toprule    
  \texttt{0x000000} & \texttt{0x3FFFFF} & 3 MiB & ROM \\
  \toprule    
  \texttt{0x800000} & \texttt{0x800007} & 8 B & JAMMA Players Inputs \\
  \texttt{0x800018} & \texttt{0x80001F} & 8 B & JAMMA Dip Switches \\
  \texttt{0x800030} & \texttt{0x800037} & 8 B & JAMMA Coin sensors \\
  \texttt{0x800176} & \texttt{0x800177} & 1 B & Kick harness \\
\toprule    
  \texttt{0x800100} & \texttt{0x80013f} & 64 B & CPS-A registers\\
  \texttt{0x800140} & \texttt{0x80017f} & 64 B & CPS-B registers\\
\toprule    
  \texttt{0x800180} & \texttt{0x800187} & 8 B & Sound commands (latch 1)\\
  \texttt{0x800188} & \texttt{0x80018F} & 8 B & Sound commands (latch 2)\\
  \toprule    
  \texttt{0x900000} & \texttt{0x92FFFF} & 192 KiB & GFXRAM\\
  \texttt{0xFF0000} & \texttt{0xFFFFFF} & 64 KiB & RAM \\
  \toprule    
\end{tabularx}%

\subsection{Memory Regions}

\lstinputlisting[]{src/code/68000/cps1.lk}

\begin{trivia}
Notice how powerful the linker script is compared to \icode{sdcc}. A directive \icode{OUTPUT\_FORMAT (" binary ")} allows outputting raw binary without using a container like \icode{elf}. This avoids the conversion step from elf to binary using \icode{objcopy}.
\end{trivia}


\lstinputlisting[]{src/code/68000/cps1-2.lk}

In the second part of the script, sections are assigned (via \textbf{\red{\textgreater}}) to a memory region using their \red{MEMORY} name.

\begin{trivia}
Notice the care taken to make sure the 68000 will only attempt to access aligned data via \icode{.ALIGN(4)} directives. Unaligned memory access is an unrecoverable error resulting in the 68000 \icode{HALT}ing.
\end{trivia}


\subsection{Code to segment}

C variables are placed into these sections using the names defined in the linker script.

\lstinputlisting[style=CStyle]{src/code/68000/memory_map.c}



\section{Initializing variables}
The linker script created markers and requested section \icode{.data} to be written to \icode{rom} (VMA) but relocated symbols (via \textbf{\red{AT\textgreater}}) as if they were in \icode{ram} (LMA).

With these elements, zeroing the bss and populating \icode{.data} with initial values is just a few lines of C.

\lstinputlisting[style=CStyle]{src/code/68000/init_vars.c}

\pagebreak
\section{Verifying RAM}
Our bootloader is simple but the ones used by Capcom did more than bringing up the CPUs. They also verify the health of hardware components. These screens are rarely, if ever, seen by players since they are visible only once when the cabinet is turned on. During normal operations, that would be when nobody is there.

All CPS-1 games display a slightly different set of text. However all of them check for faulty RAM access by the Control system. By checking the communication lines, the cabinet prevented wild goose bug hunts where a sub-system would fault because it received corrupted messages. 

By quickly ruling out a whole class of errors, the startup tests sped up debugging and brought down repairing costs.

The technique used is simple. For all bytes in each area of the RAM and GFXRAM, the m68k tries to write a value, then tries to read it back. If they differ, the memory is faulty and an error message is displayed. 

The limit of this technique is that only what is visible to the Control system can be verified. There is no way to checksum the GFXROM. While the z80 can access most of the Sound System ROM (except for the OKI ROM), it could perform checks but would have no way to surface errors since the latches can only be written from the m68k side.
\vfill
\begin{figure}[H]
\nbimg{boot_ghouls.png}
\caption*{Ghouls 'n Ghosts boot screen}
\end{figure}


\begin{figure}[H]
\nbimg{boot_sf2.png}
\caption*{Street Fighter 2 boot screen}
\end{figure}










\begin{figure}[H]
\nbimg{boot_forgottn.png}
\caption*{Forgotten Worlds boot screen}
\end{figure}



\vfill
\begin{figure}[H]
\nbimg{boot_ffight.png}
\caption*{Final Fight boot screen}
\end{figure}






\section{Ruling them all}
With each chapter peeling away a layer of complexity, we have finally reached the heart of the CP-System. 
The function \icode{main} is where developers will have their game engine convert player inputs into visual and audio outputs.

The architecture is much like the z80 sound system where two "threads" run in lockstep. Function \icode{VSync} is awakened every 16ms via an interrupt. Its job is to read inputs and save them locally, read sound/music requests, and write them to the latch. Most importantly, it flips the GFXRAM double buffered SCROLL and OBJ descriptors. 

\begin{trivia}
The \icode{frameCounter} variable paces the main thread so a new frame is only hosted every 16ms instead of rendering as fast as possible. It is also useful to keep track of wall-time to render animation and game logic properly.
\end{trivia}


\subsection{Commanding sound}
Requesting a sound or music playback is only about writing to a latch and forgetting about it. However special care is necessary if the engine requests multiple sounds during the same frame. If this were to happen the value in the latch could be overwritten before the z80 picked it up.
The solution is to implement a queue system where commands are stored and fed one by one every frame. 

Functions \icode{VSync} and \icode{main} run in lock-step via two counters. Main only runs after a sync has occurred. \icode{Sync} is always one step ahead of main function.

\lstinputlisting[style=CStyle]{src/code/68000/vsync.c} 

\subsection{Main}
\lstinputlisting[style=CStyle]{src/code/68000/main.c} 


How \icode{hostframe} is implemented is completely at the programmer's discretion. Capcom games used a common kernel framework made of tasks. Since there is no source of interrupt beside \icode{vsync} they implemented a collaborative multi-tasking system where the stack and registers are stored/loaded as each task is executed.

To learn about the kernel and how it is used to run multi-task A.I bytecode and moving fireballs, check out the Street Fighter II Platinum source code\cite{sf2platinium}.

\subsection{Retrieving inputs}
Besides joystick and buttons, the engine must recover inputs such as the dip settings, P1Start, P2Start, and most importantly detect coins being inserted.

\begin{trivia}
Arcade operators could configure the difficulty of a game via DIP switches. In Street Fighter 2, eight configurations go from the easiest where 1 coin grants six credits to the hardest where four coins grant a single credit. There is even a "Free Play" mode which no amount of begging could convince them to enable\cite{sf2manual}.
\end{trivia}

The three DIP switches are called A, B, and C. As visible on page \pageref{fig:boarda} each DIP has 8 switches responsible for flipping a bit in a byte. Recovering the configuration is as simple as reading a byte from the memory map.

\begin{trivia}
In Street Fighter 2, DIP B is used to configure the difficulty level of the game ranging from 0 to 8 (4=default). Based on this value the AI selects appropriate sets of bytecode\cite{sf2aiengine} script. Even in easy mode, the AI cheats by skipping "charging"\cite{sf2aiengine}.
\end{trivia}



 % \href{https://github.com/originalgrego/FinalFightAE-Source/blob/master/docs/known_addresses.txt}
 % \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xllr}
  \toprule    
  \textbf{Label } & \textbf{ Memory Area }  & \textbf{Address } & \textbf{Mask } \\               
  \toprule   
  
    \texttt{P1\_KEY\_3} & JAMMA Players Inputs &    \texttt{0x800000} &  \texttt{0b01000000}    \\ 
      \texttt{P1\_KEY\_2} & JAMMA Players Inputs &  \texttt{0x800000} &  \texttt{0b00100000}    \\  	
    \texttt{P1\_KEY\_1} & JAMMA Players Inputs &    \texttt{0x800000} &  \texttt{0b00010000}    \\     
  \texttt{P\_UP}    & JAMMA Players Inputs &        \texttt{0x800000} &  \texttt{0b00001000}    \\     
  \texttt{P1\_DOWN} & JAMMA Players Inputs &  \texttt{0x800000} &  \texttt{0b00000100}    \\     
  \texttt{P1\_LEFT} & JAMMA Players Inputs &  \texttt{0x800000} &  \texttt{0b00000010}    \\     
  \texttt{P1\_RIGHT} & JAMMA Players Inputs &  \texttt{0x800000} &  \texttt{0b00000001}    \\     
 
  \toprule   
    \texttt{P2\_KEY\_3} & JAMMA Players Inputs &  \texttt{0x800001}    &  \texttt{0b01000000}    \\     
  \texttt{P2\_KEY\_2} & JAMMA Players Inputs &  \texttt{0x800001}    &    \texttt{0b00100000}    \\     
  \texttt{P2\_KEY\_1} & JAMMA Players Inputs &  \texttt{0x800001}    &    \texttt{0b00010000}    \\    
  \texttt{P2\_UP}    & JAMMA Players Inputs &  \texttt{0x800001}    &     \texttt{0b00001000}    \\     
  \texttt{P2\_DOWN} & JAMMA Players Inputs &  \texttt{0x800001}    &      \texttt{0b00000100}    \\     
  \texttt{P2\_LEFT} & JAMMA Players Inputs &  \texttt{0x800001}    &      \texttt{0b00000010}    \\     
  \texttt{P2\_RIGHT} & JAMMA Players Inputs &  \texttt{0x800001}    &     \texttt{0b00000001}    \\     

  \toprule   
  \texttt{SERVICE} & JAMMA Coins &  \texttt{0x800018}       &     \texttt{0b01000000}    \\ 
   \texttt{P2\_START} & JAMMA Coins &  \texttt{0x800018}   &      \texttt{0b00100000}    \\ 
   \texttt{P1\_START} & JAMMA Coins &  \texttt{0x800018}   &      \texttt{0b00010000}    \\   
     \texttt{COIN2\_P2} & JAMMA Coins &  \texttt{0x800018}    &   \texttt{0b00000010}    \\  
   \texttt{COIN\_P1} & JAMMA Coins &  \texttt{0x800018}       &   \texttt{0b00000001}    \\      
     

    \toprule   
    \texttt{DIP1} & JAMMA DIPs &  \texttt{0x80001A}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMA DIPs &  \texttt{0x80001C}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMA DIPs &  \texttt{0x80001E}    &  \texttt{0bXXXXXXXX}    \\      
  \toprule   
\end{tabularx}
% \caption*{Input bit layouts}
% \end{figure}  

\subsection{Drawing on screen}
Requesting tiles to be drawn consists of first describing the layout in GFXRAM, then setting the palettes, and finally writing to the CPS-A and CPS-B registers to point them to "where is the data".

\subsubsection{Double buffering}
When a frame is being drawn, neither the data in the GFXRAM nor the CPS-A/CPS-B register values can be changed. Raster effects are not possible since HSYNC is not forwarded to the m68k. Changes should only occur during the VBLANKing which is signaled via the \icode{VSync} function.

The proper way to avoid visual artifacts is to double buffer the SCROLL/OBJ descriptors in the GFXRAM. While one buffer is used for rasterization until the next VSYNC, the next frame is prepared in the other buffer. On \icode{VSync} the CPS-A and CPS-B registers are written to swap the buffer roles.

\subsubsection{CPS-A and CPS-B registers}
The CPS-A registers are always at the same offset in the m68k memory map and they always use the same layout. 

Depending on the board being targeted, registers of the CPS-B will move and their internal layout will change. A convenient way to deal with this is to use MACROs and have the build system enable the appropriate ones.

Note that all registers are 16-bit to accommodate the 68000 operating on them. As shown in the summary table, a register offset is always located on an even address.

\subsubsection{CPS-A Usage}

The CPS-A is controlled via 18 registers.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }  \\     
  \toprule   
  \texttt{OBJ base}  &  \texttt{0x00} & OBJ GFXRAM absolute address   \\   
\texttt{SCROLL1 base} &  \texttt{0x02}  & SCROLL1 GFXRAM absolute address   \\         
\texttt{SCROLL2 base} &  \texttt{0x04}  & SCROLL2 GFXRAM absolute address   \\     
\texttt{SCROLL3 base}&  \texttt{0x06}   & SCROLL3 GFXRAM absolute address  \\     
\texttt{Rowscroll base} &  \texttt{0x08}  & Rowscroll GFXRAM absolute address \\     
\texttt{Palette base} &  \texttt{0x0A}  & Palettes GFXRAM absolute address  \\   
  \toprule   
\texttt{Scroll 1 X} &  \texttt{0x0C}  & SCROLL1 Offset X  \\ 
\texttt{Scroll 1 Y} &  \texttt{0x0E}  & SCROLL1 Offset Y    \\   
\texttt{Scroll 2 X} &  \texttt{0x10}  & SCROLL2 Offset X    \\ 
\texttt{Scroll 2 Y} &  \texttt{0x12}  & SCROLL2 Offset Y    \\   
\texttt{Scroll 3 X} &  \texttt{0x14}  & SCROLL3 Offset X    \\ 
\texttt{Scroll 3 Y} &  \texttt{0x16}  & SCROLL3 Offset Y    \\     
  \toprule   
\texttt{Star1    X} &  \texttt{0x18}  & STAR1   Offset X    \\  
\texttt{Star1    Y} &  \texttt{0x1A}  & STAR1   Offset Y    \\  
\texttt{Star2    X} &  \texttt{0x1C}  & STAR2   Offset X    \\  
\texttt{Star2    Y} &  \texttt{0x1E}  & STAR2   Offset Y    \\  
  \toprule   
\texttt{Rowscroll Offsets} &  \texttt{0x20}  & Offsets into Rowscroll base\\
\texttt{Video Control} &  \texttt{0x22}  & flip screen, rowscroll enable\\
  \toprule   
\end{tabularx}
\caption*{CPS-A registers (offset origin is upper-left in screen space)}
\end{figure}

The base registers tell the CPS-A where it should expect data in GFXRAM. Registers are 16-bit but addresses must be 24-bit so values are expanded \icode{<< 8} upon reception. The linker script should be configured to make sure data structures are aligned properly.

\subsubsection{Row Scrolling}
Row scrolling allows for offsetting each visible row on SCROLL2 via a discrete X amount. In Street Fighter II, Honda's dohyō ( the space in which a sumo wrestling bout occurs) perspective is achieved via linear offset differences. The more perspective needed, the more accentuated the offset slope. 

\begin{figure}[H]
\nbimg{ring_skew_none.png}
\caption*{Fighters at the center of the dohyō}
 \end{figure}%

\begin{figure}[H]
\nbimg{ring_skew_left.png}
\caption*{Fighters move to the left of the dohyō}
 \end{figure}%

\begin{figure}[H]
\nbimg{ring_skew_right.png}
\caption*{Fighters move to the right of the dohyō}
 \end{figure}%

To scroll the whole screen, the CPS-A reads 256 values. That is 224 (each visible line) + 16 (one tile height above) + 16 (one tile height below) = 256 values to render a frame.

Each unsigned 16-bit offset value is expected in an array located in GFXRAM and pointed to via the CPS-A register \icode{ROWSCROLL\_BASE}.

The \icode{ROWSCROLL\_OFFSET} instructs the CPS-A to use values not starting at \icode{ROWSCROLL\_BASE} but at \icode{ROWSCROLL\_BASE} + \icode{ROWSCROLL\_OFFSET}. 

\begin{figure}[H]
\nbdraw{rowscroll}
 \caption*{CPS-A rowscroll data access}%
 \end{figure}%

% Rowscrolling of SCROLL1 layer is achieved by two registers. Rowscroll base points to an array of 16-bit values. Rowscroll offset is an offset inside the base. How to combine them is elaborated on in the rowscroll section.


A convenient trick is to allocate a rowscroll array of size 1024 with one entry for the full height of \icode{SCROLL2} to generate all the rowscroll offsets. If \icode{SCROLL2} is scrolled vertically, the engine only needs to manipulate \icode{ROWSCROLL\_OFFSET} and no new values are to be generated.

\lstinputlisting[style=CStyle]{src/code/68000/rowscroll.c} 

\subsubsection{Real-life example}

When a contestant in Street Fighter II jumps, SCROLL2 moves vertically but no rowscroll offsets are re-calculated, only \icode{ROWSCROLL\_OFFSET}  is moved. This allows to amortize the generation of perspective correct rowscroll offset.

Note that rowscroll offsets are unsigned and always indicate an amount to move toward the left side of the screen. To offset toward the right, Street Fighter II developers took advantage of the wraparound nature of the SCROLL layers and used \icode{decalValue = 1024 - desiredRightOffsetValue}.

\paragraph{Video Control} This register enables/disables misc attributes.

\lstinputlisting[style=CStyle]{src/code/68000/videocontrol.c} 

\label{cpsbreg_programming}
\subsubsection{CPS-B Usage}
The CPS-B features only seven registers but their location changes based on the version of the chip.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }\\  
  \toprule   
  \texttt{Layer control} & \texttt{ 0x26* } & Enable and order layers\\      
\texttt{Priority mask} & \texttt{ 0x28* } &  16-bit mask pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2A* } &  16-bit mask pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2C* } &  16-bit mask pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2E* } &  16-bit mask pen values to draw above OBJ  \\  
\texttt{Palette control} & \texttt{ 0x30* } &  Request palette upload\\ 
  \toprule   
\end{tabularx}
\caption*{CPS-B registers (*: for Street Fighter 2, CPS-B 11)}
\end{figure}

\paragraph{Palette control}This register is used to request upload of palette pages, each made of 32 palettes belonging to a same layer.

\lstinputlisting[style=CStyle]{src/code/68000/palettecontrol.c} 

Palette upload does not happen immediately. Instead the CPS-A waits until the next VBLANK and starts reading at the address provided via the PALETTE base register.

The CPS-A does not use a fixed base + offset to lookup a palette page. If \icode{SCR1} page is not marked for upload, \icode{SCR2} page is expected immediately after \icode{OBJ} palette page.



\paragraph{Layer control} This register enables or disables a layer individually (with the exception of OBJ which is "disabled" by providing an empty list of tiles). It is also used to define the priority of layers \icode{OBJ}, \icode{SCROLL1}, \icode{SCROLL2}, and \icode{SCROLL3} individually.

Note that STARs are always in the back and in order STAR1, STAR2.
  
\lstinputlisting[style=CStyle]{src/code/68000/layercontrol.c} 

The board studied in this book uses a CPS-B 11 which does not support STAR1 and STAR2. These layers were also marginally used in Forgotten Words and Strider (two good reasons to allow the author to not face his laziness and avoid detailing the STARs bytecode further).



The layer control register is also used to define the order in which OBJ, SCROLL1, SCROLL2, and SCROLL3 should be drawn.

\lstinputlisting[style=CStyle]{src/code/68000/layercontrol2.c} 

\textbf{WARNING :} This bit layout changes across versions of CPS-B. What is presented here is for the CPS-B v11. Refer to Mame for documentation on other versions.

\begin{trivia}
Starfields were used so little that the bytecode mapper was removed altogether from the CPS-2 API while the ASIC retained its circuits.
\end{trivia}



\paragraph{Priority mask}
These four registers control the precedence of pens belonging to the layer behind the OBJ layer. A tile can be assigned to one priority group within a choice of four ranging within\icode{[0-3]}. A group tags pens in the tile palette to be drawn with higher priority via a 16-bit bitfield mask. Marked pens a drawn above OBJs pens.



\lstinputlisting[style=CStyle]{src/code/68000/maskcontrol.c} 

\textbf{TIP :} Tiles using priority group often use a palette where "high priority" colors are grouped together. This makes it easy to tag them in the bitfield because the bits are next to each other. e.g: Mask \icode{0xF000} marks pens \icode{15}, \icode{14}, \icode{13}, and \icode{12} as high priority.




\subsubsection{Drawing OBJs}
To draw sprites and shapes, descriptors must be written to the GFX RAM. Each entry takes four 16-bit WORDS (8 bytes).

\lstinputlisting[style=CStyle]{src/code/68000/sprites.c} 


\lstinputlisting[style=CStyle]{src/code/68000/sprites2.c}  

If the attribute WORD sets the block size to zero, a descriptor commands a single tile to be drawn. Otherwise, the command is interpreted as a Sprite rendering command using block size dimensions.

The CPS-A will stop reading entries from the OBJ descriptors if it reaches an empty entry using attribute value \icode{0xFF00} or if 256 tiles are scheduled for rendition.

\textbf{WARNING :} Sprite commands use only a single entry but every single tile in them count against the 256 tiles limit. There is no way to cheat, this is an hardware limitation, not an API limitation.


Developers do not have to worry about the \icode{STF29} or GFX partitioning. The tileID is relative to the group it belongs to.

\subsubsection{Drawing SCROLLs}

Rendering tilemap is much like rendering OBJs. Descriptors must be written to the GFX RAM but the layout is much simpler. Each entry is two 16-bit WORDs wide (four bytes).

\lstinputlisting[style=CStyle]{src/code/68000/scrolls.c} 

The attribute WORD is a bit field where we find in particular the palette ID, the group ID which references the priority mask, and the usual X/Y flippers.

\lstinputlisting[style=CStyle]{src/code/68000/scrolls2.c} 

All SCROLLs have different size and tile size but they are all considered Sprites (with rectangular dimensions). They all feature 64x64 (4,096) entries. 

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xrrr}
  \toprule    
  \textbf{Scroll name } & \textbf{ Tiles Dimensions } & \textbf{ Tile size }  & \textbf{Dimension }\\  
  \toprule   
    
\texttt{SCROLL1} & \texttt{64x64} & \texttt{8x 8 } &  \texttt{512x 512 }  \\  
\texttt{SCROLL2} & \texttt{64x64} & \texttt{16x16 } &  \texttt{1024x1024 }   \\  
\texttt{SCROLL3} & \texttt{64x64} & \texttt{32x32 } &  \texttt{2018x2048 }   \\  
  \toprule   
\end{tabularx}
\vspace*{-1mm} % Ugly hack to make release typeset be like debug. No idea why there is a difference.
\caption*{SCROLLs tile size and dimensions}
\end{figure}

If a full black layer is needed, it can be rendered without using a single tile using either SCROLL or OBJs. Enabling a STAR layer and providing zeroed bytecode does the trick. It renders a STARfield without any stars in it if the CPS-B supports STARfield.
























\pagebreak

\section{Back in the days}\index{Back in the days!Programming}
The system used by Capcom to program the CP-System remained unknown for many years. Only the nickname of Hiroaki Kondo, a composer/sound programmer often credited as "X68K", alluded to a computer manufactured by Sharp. 

In 2018,  Akiman confirmed\cite{x68000usage1}\cite{x68000usage2} that Capcom's SDK, named CAT-1, was launched during the making of Street Fighter II and ran on a Sharp X68000.

\subsection{SHARP X68000}\index{Computers!SHARP X68000}

Unheard of in the rest of the world, the X68000 is a celebrity in Japan where it was nicknamed "god computer". 
Released in 1987, the first machine in the series was as beautiful and powerful as it was expensive (¥369,000, roughly \$3000 in 1987, equivalent to \$7,600 in 2022).

\vfill

 \begin{figure}[H]
\nbimg{68000.png}
\caption*{SHARP's God Computer. Copyright G-Walk\cite{x68k_perfect_catalogue}}
\end{figure}


Despite mind-blowing hardware specifications, SHARP's new product was a risky bet considering it had next to no software at launch. To complicate things further, it used its own text-based OS named Human68k.


\begin{wrapfigure}[35]{l}{0.6\textwidth}
% \vspace{-\baselineskip}
\centering
\simg{0.6}{x68k_front.png}
\end{wrapfigure}

The "Manhattan" twin-tower case of the first model became the signature of the series. 

Notice the vertical bar between the two towers. Pushing it down releases a spring to allow the bar to extend past the top of the machine and become a carrying handle.


The ports for the keyboard, mouse, and joystick are conveniently user facing. An audio jack and a volume control are also present.

The two 5.25" floppy drives have elegant motorized "soft" ejection systems.

The three LEDs in the upper right indicates the state of the machine. \icode{POWER} is self-explanatory, \icode{HIGH RESO} indicates whether the video output is using 15KHz, 24KHz, or 31kHz, and \icode{TIMER} indicates if a self-powering is scheduled. 

In later revisions, \icode{HIGH RESO} was replaced with \icode{HD BUSY} to indicate HDD state.

On the back panel can be found "standard" ports such as additional \icode{Line In} and \icode{Line Out}, and an extra \icode{Joystick \#2} entry.  

\textbf{Images Copyright (left and right): G-Walk\cite{x68k_perfect_catalogue}}.
\pagebreak

\begin{wrapfigure}[35]{l}{0.6\textwidth}
% \vspace{-\baselineskip}
\centering
\simg{0.6}{x68k_back.png}
\end{wrapfigure}



The \icode{TV Control} port drives Sharp monitors and VCRs. It can take advantage of the timer mentioned earlier to schedule a tape recording.

The \icode{See through Color} port is for chroma-keying and rotoscoping.

A \icode{Image In} port is for transferring images from a video device, such as a VCR.

A serial port, \icode{RS232C}, as is found on many IBM PCs.



The \icode{HDD} and \icode{FDD} ports respectively allow Hard-Drive and Floppy-Drive extensions.

The \icode{100V out} outlet provides power for a monitor.

The \icode{Analog RGB out} port is the equivalent a VGA port to carry the monitor signal.


The \icode{Stereoscopic} port drives “shutter style” 3D glasses.

The \icode{Printer} port is a variant of the commonly called parallel port in USA only it is called Mini-Centronics 36-pin. 

For everything else, the X68000 features two \icode{extension slots} to welcome extension cards.

\textbf{Trivia:} The two \icode{FG} screws are meant for Frame Grounding since Japanese power outlets lack Ground wire and therefore are not grounded.


\pagebreak



\subsection{X68000 Tech specs}  
Inside its gorgeous "Manhattan" case, the machine packed an unparalleled amount of horse power. Even a machine such as the Amiga 500, released the same year and praised in Europe and USA for its prowess, pales in comparison to the X68000. 


 \begin{figure}[H]
\begin{tabularx}{\textwidth}{lXX}
  \toprule    
  \textbf{Type } & \textbf{ X68000 } & \textbf{ Amiga 500 }\\  
  \toprule   
    
CPU & M68000 10MHz & M68000 7.16 MHz\\  
RAM & 1MiB & 512 KiB\\
Max RAM & 4 MiB & 2 MiB\\ 
Colors  & 65,536 colors (stable) & 4,096 (HAM) \\
Resolution & 1024×1024 & 736x483 \\
% Graphics & 1 sprite plane, 2 bg planes, 4 bitmap planes& \\
Sprite engine & 128 units, 16x16 tiles & 8 units, 16x16 tiles\\
% Background engine & 2 in 256x256 \\
VRAM & 1056 KiB & -\\
Sound & Oki MSM6258 (1 channel)  & 4 channels PCM\\ 
Music & Yamaha YM2151 (8 channels)  & -\\ 
Price & \$5,000 & \$1,500 \\
% Storage & Dual 5.25 floppy readers  & \\ 
  \toprule   
\end{tabularx}
\caption*{X68000 vs Amiga 500}
\end{figure}


If both music and sound capabilities were outstanding, it is in the graphics department that the X68000 made jaws hit the floor.

The 1056 KiB of VRAM are divided into three segments feeding four planes. 512 KiB are dedicated to the Text plane, 512 KiB are for the Bitmap plane and the rest, 32 KiB, are for the joined use of the Background plane and Sprite plane. Each plane can be configured to use distinct resolution and layers.

\subsection{Video prowess}

The \textbf{Bitmap Plane} is particularly well suited to plot pixels and render images. Its direct 16bpp color mode was ideal for raytracing application (a M68881 math coprocessor could be added to reduce rendering time). Four modes are available.


\begin{itemize}[topsep=0pt]
% \setlength\itemsep{0.2em}
\item One 512x512 layer with direct 16bpp colors.
\item Two 512x512 layers with shared 8bpp indexed colors.
\item Four 512x512 layers with shared 4bpp indexed colors.
\item One 1024x1024 layer with 4bpp indexed colors.
\end{itemize}

The \textbf{Text Plane} is deceptively named. It is also a bitmap plane but it expects values across four bitplanes making it well suited to write large quantities of bits in few operations. A m68k writing a 16-bit word can set 16 pixels which makes text rendering very fast when copying characters from a model. Two modes are available.

\begin{itemize}[topsep=0pt]
\item One 1024x1024 layer with 4bpp indexed colors.
\item Four 512x512 layers with 1bpp monochrome.
\end{itemize}


The \textbf{TileMap Plane} offers two modes.
\begin{itemize}[topsep=0pt]
\item Two 512x512, using 8x8 tiles with 4bpp indexed colors (16 palettes).
\item One 1024x1024, using 16x16 tiles with 4bpp indexed colors (16 palettes).
\end{itemize}

The \textbf{Sprite Plane} is a sprite layer allowing 128 sprites on-screen (with a max of 32 sprites per scanlines). Each sprite uses 4bpp indexed color (16 palettes).


 \begin{figure}[H]
\nbdraw{x68k_layers}
\caption*{X68000 planes and layers. Copyright G-Walk\cite{x68k_perfect_catalogue}}
\end{figure}



In total, if all four planes are used in their most complex form, up to eleven layers can compose the screen concurrently. 

An even more impressive feat from the CRT compositor is that all layers of each plane are independently hardware scrollable.

The numerous plane capabilities made the X68000 a versatile instrument able to excel at a wide range of tasks, from simple text editing to demanding raytracing. 

Video games were obviously a strength of the machine thanks to its Background and Sprite layers although, as we will see, developers did not employ resources as one would expect.



\subsection{OS}
Developed by Hudson Soft, the operating system named Human68k is strongly inspired by Microsoft's MS-DOS . 

All English name commands such as \icode{DIR}, \icode{COPY} and such are available. In fact, Human68k manual is nearly identical to IBM DOS 4.0J manual\cite{human68k_manual}. The system even uses a \icode{CONFIG.SYS} file to boot.

\begin{figure}[H]
\img{human68k.png}
\caption*{X68000 OS, Human68k}
\end{figure}


Several windows-based GUIs running on top of Human68k were released over the years. In succession, "VS" (a.k.a) "Visual Shell" in 1987 and later SX-WINDOW (1989).

\begin{figure}[H]
\img{sx-window.png}
\caption*{SX-Window, GUI running on top of Human68k}
\end{figure}



\subsection{A Development machine?}
The similarities between the X68000 and the CPS-1 are many. A quick glance over the specs on page \pageref{x68000-specs} could easily lead one to conclude that a small layer of emulation is all a X68000 needed to run CPS-1 games, making it a perfect development machine. 

Since developers never detailed to what extent SHARP's machine was involved, we can only make an educated guess. A beginning of an answer comes from the hardware components, while Capcom-produced game ports leave no ambiguity.

\subsubsection{Hardware response}
If the Motorola 680000 CPU and the YM2151 present in both machines are identical, the rest diverge from slightly to significantly.

The sound chip is an OKI but it is "only" a MSM6258. Although it works alike the MSM6296 with ADPCM, it features only one channel which severely impacts how rich the sound effects and music systems can be.

The sprite system is, at first sight, weaker than the CPS-1 since the number of tiles displayable is half (128 instead of 256). But the X68000's  access to raster effect allowed multiplexing (the Sprite Doubler by Koichi Yoshida\cite{x68000spritedoubler}) bringing the upper limit to 512 sprites!\index{Sprites Multiplexing!X68000}

Lastly, the X68000 floppy storage resulted in slow loading time compared to the CPS-1 ROM. To solve this issue, developers used as much RAM as available, going as far as loading the whole floppies during startup if the capacity of the X68000 allowed it.



\subsubsection{The 32 KiB VRAM wall}

The real issue, and perhaps the only real weakness of the "god computer" is the minuscule amount of VRAM dedicated to feed the Sprite and Tilemap layers. Out of 1MiB, only 32KiB is available which results in asset starvation (it can store only  256 16x16 tiles). This limitation knee-capped any potential of using both layers at the same time. A VRAM shared among layers would have been a totally different story.

\subsubsection{Software response}

A definitive answer about the viability of the X68000 as a development station comes from Capcom arcade ports.
\begin{figure}[H]
\label{x68000-specs}
\begin{tabularx}{\textwidth}{lrY}
  \toprule    
  \textbf{Game } & \textbf{Year}  & \textbf{RAM Requirements } \\               
  \toprule   
  Strider & \texttt{1992} &  2 MiB \\
  Final Fight & \texttt{1992} &  2 MiB \\
  Street Fighter 2 Champion Edition & \texttt{1993} &  2 MiB \\
  Super Street Fighter II & \texttt{1994} &  4 MiB \\
  Ghouls'n Ghosts & \texttt{1994} &  2 MiB \\
    \toprule   
\end{tabularx}
\caption*{X68000 Ports of CPS-1 games by Capcom}
\end{figure}

An analysis methodology shared by Upsilandre\cite{x68k_games_analysis}, leveraging XM6 Pro-68k emulator, shows that the GFX rendering architecture of these titles exhibits no pattern of an emulation layer. On the contrary, the GFX renderers are tailor-made and rely heavily on CPU tricks. 

\begin{trivia}
The stress on the 68000 is confirmed by Ghouls 'n Ghosts manual which recommends a 16MHz CPU and warns about slowdown on a 10MHz 68000.
\end{trivia}

All these clues strongly suggest the SHARP X68000 was limited to writing/testing assembly, running TCE, and allocating/compiling the GFXROM for CPS-2 games.

\nbimg{gg_manual.jpg}


\subsection{Ports Analysis: Ghouls 'n Ghosts (1994)}
Ghouls 'n Ghosts was released in 1994, six years after the arcade version. It is noteworthy for its low RAM requirements of 2MiB RAM and its resolution of 512x512.

It is considered a "perfect port" because of its GFX faithfulness to the CPS-1 version. All the enemies, levels, and weapons are there, rendered with the correct rich colors. 

The Tilemap plane is not used at all since the background lives in two software rendered 512x512 Bitmap layers using a shared 8-bit indexed colors palette. The Text layer is also fully software rendered in 1024x1024 16 colors despite the CPU cost of plotting pixels in that mode. The cost and low number of colors makes it a good fit for rendering the GUI elements.

\begin{figure}[H]
\img{x68k_gg_scrw.png}
\caption*{Ghouls 'n Ghosts on SHARP x68000}
\end{figure}


Notice the vertical "cut" in the right of Bitmap plane Pages 0 and 1. This artifact reveals the wraparound resulting from hardware scrolling these two layers. This technique allows the CPU to render only new portion of the background. 

The Sprite layer contains more than sprites. While rendering the wind blowing in the grass only required swapping tile ID on CPS-1, the X68000 could not plot that many pixels in the Bitmap layers. Promoting blades to sprites overlays reduced the fillrate.

The rain effect is replicated as seen on page \pageref{gg_rain} via the Text layer start offset. Note there is no DMA to/from the VRAM so every single pixel except for the Sprite layer is plotted by the CPU. Thanks to hardware scrolling, that cost is amortized.

\vspace{-4ex}
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_gg_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 0}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_gg_bitmap2.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_gg_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_gg_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%


\pagebreak

\subsection{Ports Analysis: Final Fight (1992)}

Final Fight was released in 1992, three years after the arcade version. Like the Ghouls'n Ghosts port, the game managed to ship on two 5.25-inch 1.2 MiB floppies.

The graphic render uses the same trade off used by Ghouls 'n Ghosts where usage of Tilemap plane is sacrificed in favor of the ability to feed the Sprite layer with tiles. 

Two bitmap layers are used for background elements while the Text layer is used for GUI elements. All these layers are rendered in software with a draw cost amortized thanks to hardware scrolling.

The port of Final Fight to X68000 is close to the arcade version but is not considered "perfect" because of missing graphic elements and color discrepancies. 


\begin{figure}[H]
\img{x68k_ff_scr.png}
\caption*{Final Fight on X68000}
\end{figure}

The number of characters on screen was restricted to 7 which is less than the arcade version where up to 13 where visible. In this case, both the 32 KiB VRAM and the 128 tiles limits were the limiting factor since no multiplexing was possible with free roaming characters.

The Sprite sandwich trick (page \pageref{finalfight_trick}), where parts of the staircase appear in front of the Sprite is done with a special blending mode were the MSBs gives precedence over the Sprite layer. This leaves 7bpp for the color indexes and the Background ends up using 128 colors instead of 256. In other levels, this blending mode is not used so the Bitmap layers go back to using 8bpp for a total of 256 colors available.

The YM2151 let music be close to the arcade version but without samples. The OKI6295 is dedicated to playing sound effects on its only channel. These audio shortcomings can be countered via support of MIDI audio playback.

\vspace{-4ex}
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_ff_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 0}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_ff_bitmap2.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_ff_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_ff_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%


\pagebreak

\subsection{Per scene renderer}

The color-depth reduction trick is only one among many others. There are many testaments to the hair pulling process an X68000 port appears to be. One of them is the introduction sequence where Damned takes away the mayor's daughter.

The arcade version called for many sprites tiles, among them two heroes, the mini-boss Damned, Jessica, two minions (red Dug and blue Jake), and six barrels. The number of tiles far exceed the maximum 128 sprite tile limit of the X68000.

\begin{figure}[H]
\img{ff_x68000_intro.png}
\caption*{Final Fight X68000 intro sequence}
\end{figure}

To manage this problem, developers started by cutting out one minion (blue Jake). 

Since it was still too many tiles, they resorted to enabling (for the intro only) the Tilemap plane. Five our of the six barrels are drawn as tilemap in the Tilemap 0.

Since a tilemap is a simple grid of tiles with no concept of sprites and overlap, special 8x8 tiles were generated where columns of barrels are pre-overlapped.

Things get messy when animation must occur. To allow the barrels to be broken into pieces, the engine exploits the timing of enemies fleeing. First when Damned leaves, then when Dug retires, rows of barrels are progressively migrated out of the tilemap layer into the sprite layer. 



\begin{minipage}[!t]{0.49\linewidth}
\vspace{-3mm}
  \begin{figure}[H]
  \img{ff_x68000_intro_bg.png}
  \caption*{Tilemap 0 Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[!t]{0.49\linewidth}
\vspace{-3mm}
   \begin{figure}[H]
  \img{ff_x68000_intro_sprites.png}
  \caption*{Sprite Layer}
  \end{figure}
\end{minipage}

\vspace{4ex}

The whole trick is not perfect. As the barrels break down, the machine reaches its sprite tile limit. Since the engine is not as elaborated as the arcade version (page \pageref{going_too_far}), a partial Cody is drawn. 

\vspace{-4ex}
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{ff_x68000_intro2_bg.png}
  \caption*{Tilemap 0 Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{ff_x68000_intro2_sprites.png}
  \caption*{Sprite Layer}
  \end{figure}
\end{minipage}

\pagebreak

\subsection{Ports Analysis: Street Fighter II Champion Edition (1993)}
Street Fighter II Champion Edition was released only a year after the arcade version.

The volume of assets forced the game to ship on four 5.25-inch 1.2 MiB floppies. The game manages to run with 2 MiB or RAM but suffers numerous loading delays when traveling between countries. However, on a machine with 4MiB the game engine loads all floppies to RAM to provide a loading-free experience.

In terms of GFX rendering architecture, the Tilemaps are once again ignored in favor of the Sprite layer. The floors are software rendered. However the per-line parallax is considerably sped up thanks to the combination of raster effect and hardware scrolling. On each HSYNC event the horizontal hardware offset is adjusted which allows rendering Page 0 once and for all.

Some Sprite elements that used to be rendered on the CPS-1 OBJ layer found their way into the Text layer. This layer is not used for GUI but to render decorative sprites (  like the statue in Dictator level). It is likely that the 32 KiB was once again not big enough to contain the sprites for both opponents and decorations.

\begin{figure}[H]
\img{x68k_sf2ce_scrw.png}
\caption*{Street Fighter 2 CE on X68000}
\end{figure}


\pagebreak

The 32 KiB VRAM is updated during VBLANK to be populated with the tiles needed on the next frame. The X68000 RAM is used as a Sprite tile Level 1 cache.

Notice the noise in the Graphic layers, the bottom part in Page 0 and the top part in Page 1. The programmers used every avenue possible to store bytes in order to avoid loading from the floppy drives. The parts of the pages not used for composition are used to "cache" background tiles. When the CPU renders, it transfers VRAM to VRAM (sadly without DMA).

\vspace{-4ex}
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce_bitmap0.png}
  \caption*{512x512 Graphic Plane Page 0}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_sf2ce_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%

\pagebreak

Investigating further into Street Fighter 2: Champion Edition confirms the colossal task required to convert a CPS-1 title to X68000. The were three problems to solve.

\begin{enumerate}
\item Find where to store assets.
\item Remain within 32 KiB VRAM per frame.
\item Remain within the m68k software rendering budget
\end{enumerate}

\subsection{Per level renderer}
Like in Final Fight, where scenes were optimized on a case-per-case basis, Street Fighter II Champion Edition uses a distinct rendering strategy depending on the arena.

When fighting occurs in China, the Text layer is not used for Sprite decoration like it is in Thailand. Instead it is dedicated to the sky and its animation. Two rows of clouds, accounting for two "frames" of animation are drawn once. The hardware offsets are leveraged to parallax the clouds and alternate their shapes. This was likely done because of the fillrate required to update this layer.



\begin{figure}[H]
\img{x68k_sf2ce2_scrw.png}
\caption*{Street Fighter 2 CE on X68000}
\end{figure}


\subsection{Saving further 68000 cycles}
If we look closely at Page 1 and 2, we see that the background is split. The alley is on Page 2 while the rest is on Page 1, which is surprising since no parallax effect exists (they are on the same plane). 

This reduces overdraw when the Page 1 cyclist crosses the screen and goes over the other cyclist in the back alley, saving a few CPU cycles.

\begin{minipage}[t]{0.49\linewidth}
\setlength{\intextsep}{0pt}
\begin{figure}[H]
\img{x68k_sf2ce2_bitmap0.png}
\caption*{512x512 Graphic Plane Page 0}
\end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
\setlength{\intextsep}{0pt}
  \begin{figure}[H]
  \img{x68k_sf2ce2_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce2_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_sf2ce2_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%



\subsection{The Rise ...}
 SHARP kept on improving the series with better CPU (68030), more RAM (up to 12MiB) and even bigger HDD (up to 80 MiB). Peripheral manufacturers embraced the computer with extension cards covering anything users and programmers could desire. 


\begin{figure}[H]
\nbdraw{68000_series}
\caption*{Sharp X68000 series 1987-1993}
\end{figure}






 The risky bet became a phenomenal success. Users loved the platform dearly and publishers released, accounting for games only, no less than 823 titles between 1988 and 1999.


\begin{trivia}
The success was such that a magazine dedicated to the X68000, Oh!X, was published from 1988 to 2000 over 139 volumes. 

\begin{minipage}[t]{0.32\linewidth}
  \img{OhX_1990-04.png}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.32\linewidth}
 % \begin{figure}[H]
  \img{OhX_1991-02.png}
  % \caption*{Oh!X covers}
% \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.322\linewidth}
  \img{OhX_1990-10.png}
\end{minipage}%

Often featuring a raytraced cover to boast the graphic capabilities of the SHARP marvels, each publication came loaded with software, originally on one, then two, and later three 5.25" floppy disks \cite{ohXarticle}!
\end{trivia}

\subsection{... and Fall}
Ultimately, SHARP updates were too timid to keep up. Even its most recent model sporting a Motorola 68030 CPU failed to remain competitive both in terms of price and performance.

After six years without updating the video or audio pipeline, the 2D oriented design of the machine stated to look dated. Other machines found themselves better fitted to embrace an era of 3D started by companies such as Silicon Graphics, 3DfX, and Verity.

In 1993, many felt a great disturbance in the Force. SHARP had discontinued the "god computer".

